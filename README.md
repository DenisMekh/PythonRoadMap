# Неделя 1: Введение в Python

Добро пожаловать в курс по Python! Эта неделя посвящена самым основам языка программирования Python. Мы начнем с нуля, так что не переживай, если у тебя мало опыта — я объясню всё шаг за шагом. К концу недели ты сможешь писать простые программы, понимать базовый синтаксис и работать с переменными.

---

## 1. История и философия Python

Python — это язык программирования, созданный Гвидо ван Россумом в 1991 году. Он назван в честь комедийного шоу "Монти Пайтон", а не змеи! Главная идея Python — сделать код простым, читаемым и удобным для людей. Вот почему его часто выбирают новички.

### Ключевые особенности Python:
- **Простота**: Код легко читать и писать.
- **Универсальность**: Подходит для веб-разработки, анализа данных, игр и многого другого.
- **Интерпретируемость**: Ты пишешь код, и он сразу выполняется (не нужно его "компилировать", как в некоторых других языках).

Философия Python изложена в документе под названием **"The Zen of Python"**. Вот несколько строк из него:
- "Простое лучше сложного."
- "Читаемость имеет значение."

Попробуй открыть Python и ввести `import this` — ты увидишь весь "Дзен Python"!

---

## 2. Установка Python и настройка среды разработки

Чтобы начать писать код, нужно установить Python и выбрать среду разработки. Вот пошаговая инструкция:

### Установка Python
1. Перейди на официальный сайт: [python.org](https://www.python.org/downloads/).
2. Скачай последнюю версию (например, Python 3.12).
3. Запусти установщик:
   - **Windows**: Поставь галочку "Add Python to PATH" (это важно!).
   - **Mac/Linux**: Установка обычно проще, следуй инструкциям.
4. Проверь установку:
   - Открой терминал (или командную строку) и введи `python --version` (или `python3 --version`). Если видишь версию, всё готово!

### Выбор среды разработки
Среда разработки — это программа, где ты будешь писать код. Рекомендую:
- **PyCharm**: Мощная, но может быть сложной для новичков. Скачай бесплатную Community-версию с [jetbrains.com](https://www.jetbrains.com/pycharm/).
- **VS Code**: Легкий и популярный. Установи его с [code.visualstudio.com](https://code.visualstudio.com/) и добавь расширение "Python".

После установки создай файл с расширением `.py` (например, `hello.py`), и мы начнем писать код!

---

## 3. Основы синтаксиса: переменные и типы данных

### Переменные
Переменная — это "коробка", куда ты кладешь данные. В Python не нужно заранее объявлять тип переменной — просто присваивай значение.

Пример:
```python
name = "Алексей"  # Строковый тип (str)
age = 25         # Целое число (int)
height = 1.75    # Дробное число (float)
is_student = True  # Булевое значение (bool)
```

### Типы данных
Вот основные типы данных в Python:
| Тип       | Описание                  | Пример              |
|-----------|---------------------------|---------------------|
| `int`     | Целые числа              | `5`, `-10`, `42`   |
| `float`   | Дробные числа            | `3.14`, `-0.5`     |
| `str`     | Строки (текст)           | `"Привет"`, `'Мир'`|
| `bool`    | Логические значения      | `True`, `False`    |

### Операторы
Операторы позволяют выполнять действия с данными:
- **Арифметические**: `+` (сложение), `-` (вычитание), `*` (умножение), `/` (деление), `**` (возведение в степень), `%` (остаток от деления).
- **Пример**: `5 + 3 = 8`, `10 / 2 = 5.0`, `2 ** 3 = 8`.

Попробуй в Python:
```python
a = 10
b = 3
print(a + b)  # 13
print(a % b)  # 1 (остаток от деления)
```

---

## 4. Ввод и вывод данных

### Вывод: `print()`
Функция `print()` показывает текст или значения на экране.

Пример:
```python
print("Привет, мир!")  # Выводит: Привет, мир!
x = 42
print(x)              # Выводит: 42
print("Число:", x)    # Выводит: Число: 42
```

### Ввод: `input()`
Функция `input()` позволяет пользователю ввести данные.

Пример:
```python
name = input("Как тебя зовут? ")
print("Привет,", name)
```
Если ты введешь "Алексей", программа выведет: `Привет, Алексей`.

**Важно**: `input()` всегда возвращает строку. Чтобы работать с числами, преобразуй её:
```python
age = int(input("Сколько тебе лет? "))  # Преобразует строку в число
print(age + 5)  # Прибавит 5 к введённому числу
```

---

## 5. Визуализация: Как работает программа

Программа в Python выполняется сверху вниз. Вот пример потока выполнения:

```
[Начало] → [name = input()] → [print("Привет,", name)] → [Конец]
```

### Таблица типов данных
| Тип    | Пример           | Что можно сделать                     |
|--------|------------------|---------------------------------------|
| `int`  | `10`            | Сложение, вычитание, умножение        |
| `float`| `3.14`          | Дробные вычисления                    |
| `str`  | `"Python"`      | Соединение строк (конкатенация)       |
| `bool`| `True`          | Логические операции (и, или, не)      |

---

## 6. Упражнения

### Упражнение 1: Приветствие пользователя
Напиши программу, которая:
1. Запрашивает имя пользователя.
2. Выводит приветствие с его именем.

Пример вывода:
```
Как тебя зовут? Алексей
Привет, Алексей!
```

### Упражнение 2: Простой калькулятор
Напиши программу, которая:
1. Запрашивает два числа у пользователя.
2. Выводит их сумму, разность и произведение.

Пример вывода:
```
Введите первое число: 5
Введите второе число: 3
Сумма: 8
Разность: 2
Произведение: 15
```

---

## Советы по изучению
- Пиши код вручную, а не копируй — это помогает запомнить.
- Если что-то не работает, читай ошибки: они подсказывают, где проблема.
- Экспериментируй! Меняй код и смотри, что получится.

## Дополнительные ресурсы
- Официальная документация: [python.org/doc](https://docs.python.org/3/)
- Книга "Python Crash Course" (Eric Matthes) — отличный старт для новичков.

---

Поздравляю! Ты закончил первую неделю. Попробуй выполнить упражнения, и если что-то непонятно, дай знать — я объясню ещё подробнее!

# Неделя 2: Управляющие конструкции и функции

На этой неделе ты научишься управлять потоком программы с помощью условий и циклов, а также создавать функции — переиспользуемые блоки кода. Это ключевые навыки, которые позволят твоим программам принимать решения и выполнять повторяющиеся действия. Я объясню всё шаг за шагом, с примерами и визуализациями, чтобы ты легко всё понял.

---

## 1. Условные операторы (if, else, elif)

Условные операторы позволяют программе "принимать решения" в зависимости от условий.

### Синтаксис
```python
if условие:
    # код выполняется, если условие истинно
else:
    # код выполняется, если условие ложно
```

### Пример
```python
age = int(input("Сколько тебе лет? "))
if age >= 18:
    print("Ты совершеннолетний!")
else:
    print("Ты ещё несовершеннолетний.")
```

### Подробное объяснение
- `if` проверяет условие (например, `age >= 18`).
- Если условие истинно (`True`), выполняется код под `if`.
- Если ложно (`False`), выполняется код под `else`.
- Отступы (обычно 4 пробела) обязательны — они показывают, какой код относится к блоку.

### Множественные условия с `elif`
Если нужно проверить несколько условий, используй `elif` (сокращение от "else if").

Пример:
```python
temperature = int(input("Какая температура на улице? "))
if temperature > 30:
    print("Очень жарко!")
elif temperature > 20:
    print("Тепло.")
elif temperature > 0:
    print("Прохладно.")
else:
    print("Холодно!")
```

### Операторы сравнения
| Оператор | Значение              | Пример         |
|----------|-----------------------|----------------|
| `==`     | Равно                | `5 == 5` (True) |
| `!=`     | Не равно             | `5 != 3` (True) |
| `>`      | Больше               | `10 > 7` (True) |
| `<`      | Меньше               | `4 < 6` (True)  |
| `>=`     | Больше или равно     | `5 >= 5` (True) |
| `<=`     | Меньше или равно     | `3 <= 4` (True) |

### Логические операторы
- `and` — и (обе части истинны).
- `or` — или (хотя бы одна часть истинна).
- `not` — не (инверсия).

Пример:
```python
age = 15
if age >= 13 and age <= 19:
    print("Ты подросток!")
```

---

## 2. Циклы (for и while)

Циклы позволяют повторять действия. В Python есть два основных типа: `for` и `while`.

### Цикл `for`
Используется, когда известно количество повторений.

Пример:
```python
for i in range(5):  # range(5) создаёт последовательность: 0, 1, 2, 3, 4
    print("Привет", i)
```
Вывод:
```
Привет 0
Привет 1
Привет 2
Привет 3
Привет 4
```

#### Подробности `range()`
- `range(n)` — от 0 до n-1.
- `range(start, stop)` — от start до stop-1.
- `range(start, stop, step)` — с шагом step.

Пример:
```python
for i in range(2, 10, 2):  # От 2 до 9 с шагом 2
    print(i)  # Вывод: 2, 4, 6, 8
```

### Цикл `while`
Используется, когда количество повторений неизвестно, а есть условие.

Пример:
```python
count = 0
while count < 5:
    print("Счёт:", count)
    count = count + 1  # Увеличиваем count
```
Вывод:
```
Счёт: 0
Счёт: 1
Счёт: 2
Счёт: 3
Счёт: 4
```

#### Важно
- Если не обновлять переменную (например, `count`), цикл станет бесконечным!
- Используй `break` для выхода из цикла:
```python
while True:
    answer = input("Хочешь продолжить? (да/нет): ")
    if answer == "нет":
        break
```

---

## 3. Функции

Функции — это блоки кода, которые можно вызывать многократно. Они делают программы организованнее.

### Создание функции
```python
def имя_функции(аргументы):
    # код функции
    return результат  # (необязательно)
```

Пример:
```python
def say_hello(name):
    message = "Привет, " + name + "!"
    return message

print(say_hello("Алексей"))  # Вывод: Привет, Алексей!
```

### Подробности
- `def` — ключевое слово для определения функции.
- Аргументы — данные, которые передаются в функцию.
- `return` — возвращает результат (если его нет, функция возвращает `None`).

### Функция с несколькими аргументами
```python
def add_numbers(a, b):
    return a + b

result = add_numbers(5, 3)
print(result)  # Вывод: 8
```

### Значения по умолчанию
```python
def greet(name="Гость"):
    return "Привет, " + name + "!"

print(greet())        # Вывод: Привет, Гость!
print(greet("Оля"))   # Вывод: Привет, Оля!
```

---

## 4. Область видимости переменных

Переменные внутри функции "живут" только там — это **локальная область видимости**.

Пример:
```python
x = 10  # Глобальная переменная
def my_function():
    x = 5  # Локальная переменная
    print("Внутри функции:", x)

my_function()  # Вывод: Внутри функции: 5
print("Снаружи:", x)  # Вывод: Снаружи: 10
```

Если нужно изменить глобальную переменную, используй `global`:
```python
x = 10
def change_x():
    global x
    x = 20

change_x()
print(x)  # Вывод: 20
```

---

## 5. Визуализация

### Схема работы `if`
```
[Проверка условия] → [True] → [Выполнить код под if]
                  ↘ [False] → [Выполнить код под else]
```

### Жизненный цикл функции
```
[Вызов функции] → [Передача аргументов] → [Выполнение кода] → [Возврат результата]
```

---

## 6. Упражнения

### Упражнение 1: Проверка числа
Напиши программу, которая:
1. Запрашивает число у пользователя.
2. Выводит:
   - "Положительное", если число > 0.
   - "Отрицательное", если число < 0.
   - "Ноль", если число = 0.

Пример вывода:
```
Введите число: 7
Положительное
```

### Упражнение 2: Таблица умножения
Напиши функцию `multiplication_table(n)`, которая выводит таблицу умножения для числа `n` от 1 до 10.

Пример вызова:
```python
multiplication_table(3)
```
Вывод:
```
3 x 1 = 3
3 x 2 = 6
3 x 3 = 9
...
3 x 10 = 30
```

---

## Советы по изучению
- Экспериментируй с условиями и циклами — меняй значения и смотри, что получится.
- Пиши функции для повторяющихся задач — это упрощает код.
- Если застрял, печатай переменные с `print()` для отладки.

---

Поздравляю! Ты освоил вторую неделю. Выполни упражнения, и если что-то непонятно, пиши — я помогу!

# Неделя 3: Коллекции данных

На этой неделе ты познакомишься с коллекциями данных в Python — инструментами для хранения и управления наборов информации. Мы разберём списки, кортежи, множества и словари. Я объясню всё подробно, с примерами и визуализациями, чтобы ты мог уверенно работать с этими структурами.

---

## 1. Списки

Список — это упорядоченная коллекция элементов, которые можно изменять.

### Создание списка
```python
fruits = ["яблоко", "банан", "груша"]
numbers = [1, 2, 3, 4, 5]
mixed = [1, "привет", 3.14, True]  # Можно смешивать типы
```

### Индексация и срезы
- Элементы нумеруются с 0.
- Отрицательные индексы — с конца (-1 — последний элемент).

Пример:
```python
fruits = ["яблоко", "банан", "груша"]
print(fruits[0])    # Вывод: яблоко
print(fruits[-1])   # Вывод: груша
print(fruits[1:3])  # Вывод: ['банан', 'груша'] (срез от 1 до 2)
```

### Методы списков
| Метод       | Что делает                          | Пример                        |
|-------------|-------------------------------------|-------------------------------|
| `append()`  | Добавляет элемент в конец          | `fruits.append("киви")`       |
| `pop()`     | Удаляет и возвращает элемент       | `fruits.pop(1)` (удалит "банан") |
| `remove()`  | Удаляет первый подходящий элемент  | `fruits.remove("груша")`      |
| `sort()`    | Сортирует список                  | `numbers.sort()`              |
| `len()`     | Возвращает длину списка            | `len(fruits)` (например, 3)   |

Пример:
```python
fruits = ["яблоко", "банан"]
fruits.append("груша")
print(fruits)  # Вывод: ['яблоко', 'банан', 'груша']
fruits.pop(0)
print(fruits)  # Вывод: ['банан', 'груша']
```

---

## 2. Кортежи

Кортеж — это упорядоченная коллекция, которую нельзя изменить после создания.

### Создание кортежа
```python
point = (3, 4)  # Координаты
colors = ("красный", "синий", "зелёный")
single = (42,)  # Для одного элемента нужна запятая!
```

### Особенности
- Индексация работает как в списках: `point[0]` → `3`.
- Нельзя добавлять или удалять элементы.
- Используется, когда данные не должны меняться.

Пример:
```python
point = (3, 4)
print(point[1])  # Вывод: 4
# point[0] = 5  # Ошибка! Кортеж неизменяемый
```

---

## 3. Множества

Множество — это неупорядоченная коллекция уникальных элементов.

### Создание множества
```python
numbers = {1, 2, 3, 3, 4}  # Дубликаты удаляются
print(numbers)  # Вывод: {1, 2, 3, 4}
empty_set = set()  # Пустое множество
```

### Операции с множествами
| Операция         | Что делает                          | Пример                        |
|------------------|-------------------------------------|-------------------------------|
| `add()`          | Добавляет элемент                  | `numbers.add(5)`              |
| `remove()`       | Удаляет элемент (ошибка, если нет) | `numbers.remove(3)`           |
| `union()`        | Объединение множеств               | `set1.union(set2)`            |
| `intersection()` | Пересечение множеств               | `set1.intersection(set2)`     |
| `difference()`   | Разность множеств                  | `set1.difference(set2)`       |

Пример:
```python
set1 = {1, 2, 3}
set2 = {2, 3, 4}
print(set1.union(set2))         # Вывод: {1, 2, 3, 4}
print(set1.intersection(set2))  # Вывод: {2, 3}
```

---

## 4. Словари

Словарь — это коллекция пар "ключ-значение". Ключи уникальны, значения могут повторяться.

### Создание словаря
```python
person = {
    "name": "Алексей",
    "age": 25,
    "city": "Москва"
}
```

### Доступ к элементам
```python
print(person["name"])  # Вывод: Алексей
person["age"] = 26     # Изменение значения
print(person)          # Вывод: {'name': 'Алексей', 'age': 26, 'city': 'Москва'}
```

### Методы словарей
| Метод     | Что делает                          | Пример                        |
|-----------|-------------------------------------|-------------------------------|
| `keys()`  | Возвращает все ключи               | `person.keys()`               |
| `values()`| Возвращает все значения            | `person.values()`             |
| `items()` | Возвращает пары ключ-значение      | `person.items()`              |
| `get()`   | Безопасный доступ (None, если нет) | `person.get("job", "Нет")`    |
| `pop()`   | Удаляет и возвращает элемент       | `person.pop("city")`          |

Пример:
```python
person = {"name": "Оля", "age": 30}
print(person.get("name"))  # Вывод: Оля
person["job"] = "программист"
print(person)  # Вывод: {'name': 'Оля', 'age': 30, 'job': 'программист'}
```

---

## 5. Визуализация

### Таблица: Сравнение коллекций
| Тип         | Упорядоченность | Изменяемость | Уникальность | Пример                  |
|-------------|-----------------|--------------|--------------|-------------------------|
| Список      | Да             | Да           | Нет          | `[1, 2, 2, 3]`         |
| Кортеж      | Да             | Нет          | Нет          | `(1, 2, 3)`            |
| Множество   | Нет            | Да           | Да           | `{1, 2, 3}`            |
| Словарь     | Да (с Python 3.7)| Да         | Ключи — да   | `{"a": 1, "b": 2}`     |

### Структура словаря
```
Ключ: "name" → Значение: "Алексей"
Ключ: "age"  → Значение: 25
Ключ: "city" → Значение: "Москва"
```

---

## 6. Упражнения

### Упражнение 1: Подсчёт слов
Напиши программу, которая:
1. Запрашивает строку у пользователя.
2. Разбивает её на слова.
3. Используя словарь, подсчитывает, сколько раз каждое слово встречается.

Пример вывода:
```
Введите строку: яблоко банан яблоко груша
яблоко: 2
банан: 1
груша: 1
```

Подсказка: Используй `split()` для разбиения строки на список слов.

### Упражнение 2: Работа со списками
Напиши программу, которая:
1. Создаёт список из 5 чисел, введённых пользователем.
2. Выводит сумму всех чисел и их среднее значение.

Пример вывода:
```
Введите число 1: 2
Введите число 2: 4
Введите число 3: 6
Введите число 4: 8
Введите число 5: 10
Сумма: 30
Среднее: 6.0
```

---

## Советы по изучению
- Попробуй комбинировать коллекции: например, список словарей.
- Используй `print()` для проверки содержимого коллекций.
- Запоминай методы — они сильно упрощают работу!

---

Поздравляю! Ты освоил третью неделю. Выполни упражнения, и если что-то непонятно, дай знать — я объясню ещё подробнее!

# Неделя 4: Строки и файлы

На этой неделе ты освоишь работу с текстовыми данными (строками) и файлами, а также научишься обрабатывать ошибки, которые могут возникнуть. Я объясню всё максимально подробно, с примерами и визуализациями, чтобы ты мог уверенно применять эти навыки.

---

## 1. Строки: Работа с текстом

Строка — это последовательность символов, заключённая в кавычки (`"..."` или `'...'`).

### Основные операции
```python
text = "Привет, Python!"
print(text[0])      # Вывод: П (индексация с 0)
print(text[8:14])   # Вывод: Python (срез)
print(len(text))    # Вывод: 15 (длина строки)
```

### Методы строк
| Метод       | Что делает                          | Пример                        |
|-------------|-------------------------------------|-------------------------------|
| `split()`   | Разбивает строку на список         | `"a,b,c".split(",")` → `["a", "b", "c"]` |
| `join()`    | Объединяет список в строку         | `",".join(["a", "b"])` → `"a,b"` |
| `replace()` | Заменяет подстроку                 | `"cat".replace("c", "r")` → `"rat"` |
| `strip()`   | Удаляет пробелы с краёв            | `"  hi  ".strip()` → `"hi"`   |
| `upper()`   | Переводит в верхний регистр        | `"hello".upper()` → `"HELLO"` |
| `lower()`   | Переводит в нижний регистр         | `"HELLO".lower()` → `"hello"` |

Пример:
```python
text = "  Python - крутой язык!  "
print(text.strip())          # Вывод: Python - крутой язык!
print(text.split())          # Вывод: ['Python', '-', 'крутой', 'язык!']
print("!".join(["a", "b"]))  # Вывод: a!b
```

### Форматирование строк
Есть несколько способов вставить данные в строку:
1. **Конкатенация**:
```python
name = "Алексей"
print("Привет, " + name + "!")  # Вывод: Привет, Алексей!
```

2. **f-строки** (рекомендуется):
```python
age = 25
print(f"Мне {age} лет.")  # Вывод: Мне 25 лет.
```

3. **Метод `.format()`**:
```python
print("Меня зовут {}. Мне {} лет.".format("Оля", 30))  # Вывод: Меня зовут Оля. Мне 30 лет.
```

---

## 2. Работа с файлами

Python позволяет читать и записывать данные в файлы.

### Чтение файла
```python
with open("example.txt", "r", encoding="utf-8") as file:
    content = file.read()
    print(content)
```
- `"r"` — режим чтения.
- `encoding="utf-8"` — поддержка кириллицы.
- `with` — автоматически закрывает файл после работы.

### Запись в файл
```python
with open("example.txt", "w", encoding="utf-8") as file:
    file.write("Привет, это текст в файле!\n")
```
- `"w"` — режим записи (перезаписывает файл).
- `\n` — перенос строки.

### Добавление в файл
```python
with open("example.txt", "a", encoding="utf-8") as file:
    file.write("Новая строка.\n")
```
- `"a"` — режим добавления (дописывает в конец).

Пример:
1. Создай файл `test.txt` с текстом:
```
Первая строка
Вторая строка
```
2. Прочитай его:
```python
with open("test.txt", "r", encoding="utf-8") as file:
    lines = file.readlines()  # Читает строки в список
    print(lines)  # Вывод: ['Первая строка\n', 'Вторая строка\n']
```

---

## 3. Обработка исключений

Ошибки случаются (например, файл не найден). Чтобы программа не "ломалась", используй `try-except`.

### Синтаксис
```python
try:
    # Код, который может вызвать ошибку
except ТипОшибки:
    # Что делать, если ошибка произошла
```

Пример:
```python
try:
    number = int(input("Введите число: "))
    print(10 / number)
except ValueError:
    print("Ошибка: нужно ввести число!")
except ZeroDivisionError:
    print("Ошибка: деление на ноль!")
```
- `ValueError` — если ввели не число.
- `ZeroDivisionError` — если ввели 0.

### Полный синтаксис
```python
try:
    with open("missing.txt", "r") as file:
        print(file.read())
except FileNotFoundError:
    print("Файл не найден!")
finally:
    print("Этот код выполнится всегда.")
```

---

## 4. Визуализация

### Примеры форматирования строк
| Способ         | Пример                              | Результат                  |
|----------------|-------------------------------------|----------------------------|
| Конкатенация   | `"Hi, " + "Alex"`                  | `Hi, Alex`                |
| f-строка       | `f"Hi, {name}"`                    | `Hi, Алексей`             |
| `.format()`    | `"Hi, {}".format("Olya")`          | `Hi, Olya`                |

### Процесс чтения/записи файла
```
[Открытие файла] → [Чтение/Запись] → [Закрытие файла]
```

---

## 5. Упражнения

### Упражнение 1: Подсчёт слов в файле
Напиши программу, которая:
1. Читает текстовый файл (создай его заранее).
2. Подсчитывает количество слов в нём.

Пример файла `text.txt`:
```
Это пример текста для подсчёта слов.
```
Вывод:
```
Количество слов: 7
```

Подсказка: Используй `split()`.

### Упражнение 2: Замена символов
Напиши функцию `replace_spaces(text)`, которая:
1. Принимает строку.
2. Заменяет все пробелы на подчёркивания.
3. Возвращает результат.

Пример вызова:
```python
print(replace_spaces("Привет мой друг"))  # Вывод: Привет_мой_друг
```

---

## Советы по изучению
- Экспериментируй с методами строк — они очень полезны!
- Создай несколько тестовых файлов и потренируйся с чтением/записью.
- Всегда используй `try-except` при работе с файлами.

---

Поздравляю! Ты освоил четвёртую неделю. Выполни упражнения, и если что-то непонятно, пиши — я помогу!

# Неделя 5: Объектно-ориентированное программирование (ООП)

На этой неделе ты глубоко погрузишься в объектно-ориентированное программирование (ООП) — один из ключевых подходов в Python. Мы разберём классы, объекты, наследование, полиморфизм, инкапсуляцию и абстракцию, а также познакомимся с дополнительными возможностями, такими как специальные методы и свойства. Я объясню всё максимально подробно, с примерами и визуализациями, чтобы ты мог уверенно применять ООП в своих проектах.

---

## 1. Классы и объекты: Основы

### Что такое класс и объект?
- **Класс** — это шаблон или "чертеж" для создания объектов. Например, "Автомобиль" — это класс.
- **Объект** — конкретный экземпляр класса. Например, "Моя Toyota" — это объект.

### Создание класса
```python
class Car:
    def __init__(self, brand, model, year):  # Конструктор
        self.brand = brand  # Атрибуты объекта
        self.model = model
        self.year = year
        self.mileage = 0    # Атрибут с начальным значением
    
    def drive(self, distance):  # Метод
        self.mileage += distance
        return f"{self.brand} {self.model} проехала {distance} км."

# Создание объектов
car1 = Car("Toyota", "Camry", 2020)
car2 = Car("Honda", "Civic", 2018)

print(car1.brand)         # Вывод: Toyota
print(car2.drive(100))    # Вывод: Honda Civic проехала 100 км.
print(car2.mileage)       # Вывод: 100
```

### Подробности
- `__init__` — метод, который вызывается при создании объекта. Он задаёт начальные значения атрибутов.
- `self` — ссылка на текущий объект. Через неё обращаемся к атрибутам и методам.
- Атрибуты — это данные объекта (например, `brand`, `mileage`).
- Методы — это действия, которые объект может выполнять (например, `drive`).

---

## 2. Наследование: Расширение классов

Наследование позволяет создавать новые классы на основе существующих, добавляя или изменяя функциональность.

### Пример
```python
class Vehicle:
    def __init__(self, brand):
        self.brand = brand
        self.speed = 0
    
    def accelerate(self, increase):
        self.speed += increase
        return f"Скорость: {self.speed} км/ч"

class Car(Vehicle):  # Car наследует Vehicle
    def __init__(self, brand, model):
        super().__init__(brand)  # Вызов конструктора родителя
        self.model = model
    
    def honk(self):  # Новый метод
        return f"{self.brand} {self.model} сигналит: Бип-бип!"

class Bicycle(Vehicle):
    def ring_bell(self):
        return f"{self.brand} звенит: Динь-динь!"

car = Car("Toyota", "Corolla")
bike = Bicycle("Giant")
print(car.accelerate(50))  # Вывод: Скорость: 50 км/ч
print(car.honk())          # Вывод: Toyota Corolla сигналит: Бип-бип!
print(bike.ring_bell())    # Вывод: Giant звенит: Динь-динь!
```

### Подробности
- `super()` — вызывает методы родительского класса.
- Дочерние классы (`Car`, `Bicycle`) наследуют атрибуты и методы `Vehicle`, но могут добавлять свои или переопределять существующие.

---

## 3. Полиморфизм: Гибкость методов

Полиморфизм позволяет использовать один и тот же метод для разных объектов с разным поведением.

### Пример
```python
class Animal:
    def __init__(self, name):
        self.name = name
    
    def make_sound(self):  # Базовый метод
        return "Какой-то звук"

class Dog(Animal):
    def make_sound(self):  # Переопределение
        return f"{self.name} говорит: Гав!"

class Cat(Animal):
    def make_sound(self):
        return f"{self.name} говорит: Мяу!"

animals = [Dog("Шарик"), Cat("Мурка")]
for animal in animals:
    print(animal.make_sound())
```
Вывод:
```
Шарик говорит: Гав!
Мурка говорит: Мяу!
```

### Подробности
- Метод `make_sound()` работает по-разному в зависимости от класса объекта.
- Это удобно для работы с набором объектов через общий интерфейс.

---

## 4. Инкапсуляция: Защита данных

Инкапсуляция скрывает внутренние данные объекта и предоставляет доступ через методы.

### Пример
```python
class BankAccount:
    def __init__(self, owner, balance):
        self.owner = owner
        self.__balance = balance  # Приватный атрибут
    
    def deposit(self, amount):  # Публичный метод
        if amount > 0:
            self.__balance += amount
            return f"Внесено {amount}. Новый баланс: {self.__balance}"
        return "Сумма должна быть положительной!"
    
    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            return f"Снято {amount}. Новый баланс: {self.__balance}"
        return "Недостаточно средств или неверная сумма!"
    
    def get_balance(self):  # Геттер
        return self.__balance

account = BankAccount("Алексей", 1000)
print(account.deposit(500))    # Вывод: Внесено 500. Новый баланс: 1500
print(account.withdraw(200))   # Вывод: Снято 200. Новый баланс: 1300
print(account.get_balance())   # Вывод: 1300
# print(account.__balance)     # Ошибка! Атрибут скрыт
```

### Подробности
- `__balance` — приватный атрибут (два подчёркивания делают его недоступным напрямую).
- Методы `deposit`, `withdraw`, `get_balance` — публичный интерфейс для работы с данными.
- Одиночное подчёркивание (`_balance`) — "защищённый" атрибут по соглашению, но доступен.

---

## 5. Абстракция: Упрощение интерфейса

Абстракция скрывает сложные детали и предоставляет простой интерфейс. В Python это часто реализуется через абстрактные базовые классы (модуль `abc`).

### Пример
```python
from abc import ABC, abstractmethod

class Shape(ABC):  # Абстрактный базовый класс
    @abstractmethod
    def area(self):  # Абстрактный метод
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):  # Реализация метода
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14 * self.radius ** 2

rect = Rectangle(4, 5)
circle = Circle(3)
print(rect.area())    # Вывод: 20
print(circle.area())  # Вывод: 28.26
# shape = Shape()     # Ошибка! Нельзя создать объект абстрактного класса
```

### Подробности
- `ABC` — базовый класс для абстракции.
- `@abstractmethod` — указывает, что метод должен быть реализован в дочерних классах.

---

## 6. Специальные методы (Магические методы)

Специальные методы позволяют классам вести себя как встроенные типы Python (например, поддерживать `+`, `len()`).

### Пример
```python
class Book:
    def __init__(self, title, pages):
        self.title = title
        self.pages = pages
    
    def __str__(self):  # Строковое представление
        return f"Книга: {self.title}"
    
    def __len__(self):  # Длина (количество страниц)
        return self.pages
    
    def __add__(self, other):  # Сложение объектов
        return self.pages + other.pages

book1 = Book("Python 101", 300)
book2 = Book("OOP Basics", 200)
print(str(book1))      # Вывод: Книга: Python 101
print(len(book1))      # Вывод: 300
print(book1 + book2)   # Вывод: 500
```

### Популярные специальные методы
| Метод       | Назначение                  | Пример                     |
|-------------|-----------------------------|----------------------------|
| `__str__`   | Строковое представление     | `str(obj)`                 |
| `__len__`   | Длина объекта              | `len(obj)`                 |
| `__add__`   | Оператор `+`               | `obj1 + obj2`              |
| `__eq__`    | Сравнение (`==`)           | `obj1 == obj2`             |

---

## 7. Визуализация

### Иерархия классов
```
[Vehicle]
   ├── [Car] → [honk()]
   └── [Bicycle] → [ring_bell()]
```

### Таблица: Публичные vs Приватные атрибуты
| Тип атрибута    | Обозначение       | Доступ            | Пример            |
|-----------------|-------------------|-------------------|-------------------|
| Публичный       | `name`            | Прямой            | `car.name`        |
| Защищённый      | `_name`           | По соглашению     | `car._name`       |
| Приватный       | `__name`          | Через методы      | `car.get_name()`  |

---

## 8. Упражнения

### Упражнение 1: Класс "Студент" (расширенный)
Напиши класс `Student`:
1. Атрибуты: `name` (имя), `grades` (список оценок), `__total_score` (приватный, сумма оценок).
2. Методы:
   - `add_grade(grade)` — добавляет оценку и обновляет `__total_score`.
   - `average_grade()` — возвращает средний балл.
   - `__str__` — возвращает строку вида "Студент: {name}, средний балл: {average}".

Пример вызова:
```python
student = Student("Алексей", [5, 4])
student.add_grade(3)
print(student)  # Вывод: Студент: Алексей, средний балл: 4.0
```

### Упражнение 2: Наследование и полиморфизм
Создай:
1. Абстрактный класс `Employee` с методом `calculate_salary()` (абстрактный).
2. Дочерние классы:
   - `HourlyEmployee` (зарплата = часы * ставка).
   - `SalariedEmployee` (фиксированная зарплата).

Пример вывода:
```python
emp1 = HourlyEmployee("Оля", 20, 500)  # часы, ставка
emp2 = SalariedEmployee("Игорь", 50000)  # фиксированная
print(emp1.calculate_salary())  # Вывод: 10000
print(emp2.calculate_salary())  # Вывод: 50000
```

---

## Советы по изучению
- Создавай классы для реальных объектов (например, "Книга", "Сотрудник").
- Экспериментируй с наследованием и специальными методами.
- Используй инкапсуляцию для защиты важных данных.

---

Поздравляю! Ты освоил расширенную пятую неделю. Теперь ты знаешь ООП на гораздо более глубоком уровне. Выполни упражнения, и если что-то непонятно, пиши — я помогу!
# Неделя 6: Модули и пакеты

На этой неделе ты узнаешь, как организовывать код в модули и пакеты, а также как использовать стандартные и сторонние библиотеки Python. Это поможет тебе писать более структурированные программы и экономить время, используя готовые решения. Я объясню всё шаг за шагом, с примерами и визуализациями.

---

## 1. Импорт модулей

Модуль — это файл с кодом Python (`.py`), который можно подключать в другие программы.

### Пример стандартных модулей
```python
import math
print(math.pi)        # Вывод: 3.141592653589793
print(math.sqrt(16))  # Вывод: 4.0

import random
print(random.randint(1, 10))  # Вывод: случайное число от 1 до 10
```

### Варианты импорта
- Импорт всего модуля: `import math`.
- Импорт конкретного элемента: `from math import pi`.
- Импорт с псевдонимом: `import random as rnd`.

Пример:
```python
from random import choice
items = ["яблоко", "банан", "груша"]
print(choice(items))  # Вывод: случайный элемент, например "банан"
```

---

## 2. Создание собственных модулей

Ты можешь создать свой модуль, сохранив код в файл с расширением `.py`.

### Пример
1. Создай файл `my_module.py`:
```python
def greet(name):
    return f"Привет, {name}!"

favorite_number = 42
```

2. Используй его в другом файле (например, `main.py`):
```python
import my_module

print(my_module.greet("Алексей"))  # Вывод: Привет, Алексей!
print(my_module.favorite_number)   # Вывод: 42
```

### Подробности
- Файлы должны быть в одной папке (или указать путь).
- Переменные, функции и классы из модуля доступны через точку (`.`).

---

## 3. Пакеты

Пакет — это папка с модулями и специальным файлом `__init__.py` (может быть пустым).

### Структура пакета
```
my_package/
├── __init__.py
├── module1.py
└── module2.py
```

1. Создай файл `module1.py`:
```python
def say_hello():
    return "Привет из module1!"
```

2. Создай файл `module2.py`:
```python
def say_bye():
    return "Пока из module2!"
```

3. Используй пакет в `main.py`:
```python
from my_package import module1, module2

print(module1.say_hello())  # Вывод: Привет из module1!
print(module2.say_bye())    # Вывод: Пока из module2!
```

### Подробности
- `__init__.py` делает папку пакетом.
- Можно импортировать конкретные функции: `from my_package.module1 import say_hello`.

---

## 4. Установка сторонних библиотек

Для установки библиотек используется `pip` — менеджер пакетов Python.

### Пример
1. Установи библиотеку `requests`:
```
pip install requests
```
2. Используй её:
```python
import requests
response = requests.get("https://api.github.com")
print(response.status_code)  # Вывод: 200 (успех)
```

### Полезные библиотеки
| Библиотека   | Для чего                  | Команда установки      |
|--------------|---------------------------|------------------------|
| `requests`   | Работа с HTTP-запросами   | `pip install requests` |
| `numpy`      | Математические вычисления | `pip install numpy`    |
| `matplotlib` | Построение графиков       | `pip install matplotlib` |

---

## 5. Визуализация

### Таблица: Популярные стандартные модули
| Модуль     | Назначение                        | Пример использования            |
|------------|-----------------------------------|---------------------------------|
| `math`     | Математические функции           | `math.sin(math.pi / 2)` → `1.0` |
| `random`   | Генерация случайных чисел        | `random.choice([1, 2, 3])`      |
| `datetime` | Работа с датой и временем        | `datetime.date.today()`         |
| `os`       | Работа с операционной системой   | `os.getcwd()`                   |

### Структура пакета
```
[my_package]
   ├── [__init__.py]
   ├── [module1.py] → [say_hello()]
   └── [module2.py] → [say_bye()]
```

---

## 6. Упражнения

### Упражнение 1: Математический модуль
1. Создай файл `math_utils.py` с функциями:
   - `add(a, b)` — возвращает сумму.
   - `multiply(a, b)` — возвращает произведение.
2. В другом файле импортируй и используй эти функции.

Пример вызова:
```python
import math_utils
print(math_utils.add(5, 3))       # Вывод: 8
print(math_utils.multiply(4, 6))  # Вывод: 24
```

### Упражнение 2: Случайный выбор
Напиши программу, которая:
1. Использует модуль `random`.
2. Запрашивает у пользователя список слов (через запятую).
3. Выбирает случайное слово и выводит его.

Пример вывода:
```
Введите слова через запятую: кот, собака, птица
Случайное слово: собака
```

---

## Советы по изучению
- Разделяй код на модули, если он становится большим.
- Изучай документацию стандартных модулей на [python.org](https://docs.python.org/3/library/).
- Экспериментируй с `pip` — устанавливай и пробуй новые библиотеки.

---

Поздравляю! Ты освоил шестую неделю. Теперь ты можешь организовывать код и использовать библиотеки. Выполни упражнения, и если что-то непонятно, пиши — я помогу!

# Неделя 7: Продвинутые темы

На этой неделе ты освоишь продвинутые возможности Python, которые сделают твой код мощнее и эффективнее. Мы разберём декораторы, генераторы, контекстные менеджеры и основы многопоточности/многопроцессорности. Я объясню всё шаг за шагом, с примерами и визуализациями, чтобы ты мог уверенно применять эти концепции.

---

## 1. Декораторы

Декораторы — это функции, которые изменяют поведение других функций или методов.

### Основы
```python
def my_decorator(func):
    def wrapper():
        print("До выполнения функции")
        func()
        print("После выполнения функции")
    return wrapper

@my_decorator  # Применение декоратора
def say_hello():
    print("Привет!")

say_hello()
```
Вывод:
```
До выполнения функции
Привет!
После выполнения функции
```

### Подробности
- `@my_decorator` — синтаксический сахар для `say_hello = my_decorator(say_hello)`.
- `wrapper` — внутренняя функция, которая "оборачивает" оригинальную.

### Декораторы с аргументами
```python
def repeat(n):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(n):
                func(*args, **kwargs)
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    print(f"Привет, {name}!")

greet("Алексей")
```
Вывод:
```
Привет, Алексей!
Привет, Алексей!
Привет, Алексей!
```

---

## 2. Генераторы и итераторы

Генераторы позволяют создавать последовательности "на лету", экономя память.

### Простой генератор
```python
def count_up_to(n):
    for i in range(1, n + 1):
        yield i  # Возвращает значение и "замораживает" выполнение

gen = count_up_to(5)
print(next(gen))  # Вывод: 1
print(next(gen))  # Вывод: 2
for num in gen:   # Продолжает с 3
    print(num)    # Вывод: 3, 4, 5
```

### Генераторное выражение
```python
squares = (x ** 2 for x in range(5))
print(list(squares))  # Вывод: [0, 1, 4, 9, 16]
```

### Подробности
- `yield` — ключевое слово для генераторов, возвращает значение и сохраняет состояние.
- Генераторы полезны для работы с большими данными, так как не хранят всё в памяти сразу.

---

## 3. Контекстные менеджеры

Контекстные менеджеры упрощают работу с ресурсами (например, файлами), автоматически закрывая их.

### Использование `with`
```python
with open("example.txt", "w") as file:
    file.write("Привет, мир!")
# Файл автоматически закрыт после блока
```

### Создание своего контекстного менеджера
```python
class Timer:
    def __init__(self):
        self.start = None
    
    def __enter__(self):
        import time
        self.start = time.time()
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        import time
        print(f"Время выполнения: {time.time() - self.start:.2f} сек")

with Timer() as t:
    for _ in range(1000000):
        pass
# Вывод: Время выполнения: 0.05 сек (примерное значение)
```

### Подробности
- `__enter__` — выполняется при входе в блок `with`.
- `__exit__` — выполняется при выходе, даже если произошла ошибка.

---

## 4. Многопоточность и многопроцессорность

Эти техники позволяют выполнять задачи параллельно.

### Многопоточность (threading)
Подходит для задач, ограниченных вводом-выводом (I/O-bound).

```python
import threading
import time

def task(name):
    print(f"Задача {name} началась")
    time.sleep(2)  # Имитация работы
    print(f"Задача {name} завершена")

threads = []
for i in range(3):
    t = threading.Thread(target=task, args=(f"T{i}",))
    threads.append(t)
    t.start()

for t in threads:
    t.join()  # Ждём завершения всех потоков
```
Вывод (примерный):
```
Задача T0 началась
Задача T1 началась
Задача T2 началась
Задача T0 завершена
Задача T1 завершена
Задача T2 завершена
```

### Многопроцессорность (multiprocessing)
Подходит для задач, ограниченных процессором (CPU-bound).

```python
from multiprocessing import Process
import time

def square_numbers(numbers):
    result = [n ** 2 for n in numbers]
    print(f"Результат: {result}")

if __name__ == "__main__":
    processes = []
    data = [range(5), range(5, 10)]
    for chunk in data:
        p = Process(target=square_numbers, args=(chunk,))
        processes.append(p)
        p.start()
    
    for p in processes:
        p.join()
```
Вывод (примерный):
```
Результат: [0, 1, 4, 9, 16]
Результат: [25, 36, 49, 64, 81]
```

### Подробности
- `threading` — потоки в одном процессе, делят память.
- `multiprocessing` — отдельные процессы, не делят память.

---

## 5. Визуализация

### Работа декоратора
```
[Вызов greet()] → [repeat(3)] → [wrapper()] → [greet() x 3]
```

### График: Потоки vs Процессы
```
Потоки:    [T1]---[T2]---[T3]--- (один процесс)
Процессы:  [P1] | [P2] | [P3]    (параллельно)
```

---

## 6. Упражнения

### Упражнение 1: Декоратор времени
Напиши декоратор `time_it`, который замеряет и выводит время выполнения функции.

Пример вызова:
```python
@time_it
def slow_function():
    time.sleep(1)
    print("Функция выполнена")

slow_function()
```
Вывод:
```
Функция выполнена
Время: 1.01 сек
```

### Упражнение 2: Генератор Фибоначчи
Напиши генератор `fibonacci(n)`, который возвращает первые `n` чисел Фибоначчи.

Пример вызова:
```python
fib = fibonacci(6)
print(list(fib))  # Вывод: [0, 1, 1, 2, 3, 5]
```

---

## Советы по изучению
- Экспериментируй с декораторами, добавляя разную логику.
- Используй генераторы для больших данных.
- Тестируй многопоточность на простых задачах (например, загрузка файлов).

---

Поздравляю! Ты освоил седьмую неделю и теперь знаешь продвинутые техники Python. Выполни упражнения, и если что-то непонятно, пиши — я помогу!

# Неделя 8: Практические проекты

На этой неделе ты применишь все изученные навыки, создавая полноценные проекты. Мы разберём разработку, тестирование, оптимизацию и документирование кода. Я дам тебе два примера проектов и подробные инструкции, чтобы ты мог завершить курс с практическим опытом.

---

## 1. Разработка проекта

Ты можешь выбрать один из предложенных проектов или придумать свой. Вот два варианта:
- **Игра "Крестики-нолики"** — классическая игра с использованием ООП и логики.
- **To-Do список** — приложение для управления задачами с сохранением в файл.

### Проект 1: Крестики-нолики
Создадим игру для двух игроков (X и O).

#### Код
```python
class TicTacToe:
    def __init__(self):
        self.board = [" " for _ in range(9)]  # Доска 3x3
        self.current_player = "X"
    
    def print_board(self):
        for i in range(0, 9, 3):
            print(f"{self.board[i]} | {self.board[i+1]} | {self.board[i+2]}")
            if i < 6:
                print("-" * 9)
    
    def make_move(self, position):
        if 1 <= position <= 9 and self.board[position-1] == " ":
            self.board[position-1] = self.current_player
            self.current_player = "O" if self.current_player == "X" else "X"
            return True
        return False
    
    def check_winner(self):
        # Проверка строк, столбцов и диагоналей
        wins = [(0,1,2), (3,4,5), (6,7,8),  # Строки
                (0,3,6), (1,4,7), (2,5,8),  # Столбцы
                (0,4,8), (2,4,6)]           # Диагонали
        for a, b, c in wins:
            if self.board[a] == self.board[b] == self.board[c] != " ":
                return self.board[a]
        return None if " " not in self.board else False

def play_game():
    game = TicTacToe()
    while True:
        game.print_board()
        move = int(input(f"Игрок {game.current_player}, выбери позицию (1-9): "))
        if not game.make_move(move):
            print("Неверный ход! Попробуй снова.")
            continue
        winner = game.check_winner()
        if winner:
            game.print_board()
            if winner == "X" or winner == "O":
                print(f"Победил игрок {winner}!")
            else:
                print("Ничья!")
            break

if __name__ == "__main__":
    play_game()
```
Вывод (пример):
```
  |   |  
---------
  |   |  
---------
  |   |  
Игрок X, выбери позицию (1-9): 1
X |   |  
---------
  |   |  
---------
  |   |  
Игрок O, выбери позицию (1-9): 5
...
```

#### Подробности
- Используется класс `TicTacToe` (ООП).
- Логика проверки победителя проверяет все возможные комбинации.

---

### Проект 2: To-Do список
Создадим приложение для управления задачами с сохранением в файл.

#### Код
```python
import json

class TaskManager:
    def __init__(self, filename="tasks.json"):
        self.filename = filename
        self.tasks = self.load_tasks()
    
    def load_tasks(self):
        try:
            with open(self.filename, "r", encoding="utf-8") as file:
                return json.load(file)
        except (FileNotFoundError, json.JSONDecodeError):
            return []
    
    def save_tasks(self):
        with open(self.filename, "w", encoding="utf-8") as file:
            json.dump(self.tasks, file, ensure_ascii=False, indent=4)
    
    def add_task(self, task):
        self.tasks.append({"task": task, "done": False})
        self.save_tasks()
    
    def complete_task(self, index):
        if 0 <= index < len(self.tasks):
            self.tasks[index]["done"] = True
            self.save_tasks()
    
    def show_tasks(self):
        for i, task in enumerate(self.tasks):
            status = "✓" if task["done"] else " "
            print(f"{i}. [{status}] {task['task']}")

def main():
    manager = TaskManager()
    while True:
        print("\n1. Добавить задачу\n2. Завершить задачу\n3. Показать задачи\n4. Выход")
        choice = input("Выбери действие: ")
        if choice == "1":
            task = input("Введи задачу: ")
            manager.add_task(task)
        elif choice == "2":
            manager.show_tasks()
            index = int(input("Номер задачи для завершения: "))
            manager.complete_task(index)
        elif choice == "3":
            manager.show_tasks()
        elif choice == "4":
            break

if __name__ == "__main__":
    main()
```
Вывод (пример):
```
1. Добавить задачу
2. Завершить задачу
3. Показать задачи
4. Выход
Выбери действие: 1
Введи задачу: Купить молоко
...
3. Показать задачи
0. [ ] Купить молоко
```

#### Подробности
- Используется JSON для сохранения задач в файл.
- ООП (класс `TaskManager`) и обработка исключений.

---

## 2. Тестирование и отладка

### Тестирование
Добавим простые тесты для `TicTacToe` с помощью модуля `unittest`.

```python
import unittest

class TestTicTacToe(unittest.TestCase):
    def setUp(self):
        self.game = TicTacToe()
    
    def test_make_move(self):
        self.assertTrue(self.game.make_move(1))
        self.assertEqual(self.game.board[0], "X")
        self.assertFalse(self.game.make_move(1))  # Позиция занята
    
    def test_winner(self):
        self.game.make_move(1)  # X
        self.game.make_move(4)  # O
        self.game.make_move(2)  # X
        self.game.make_move(5)  # O
        self.game.make_move(3)  # X
        self.assertEqual(self.game.check_winner(), "X")

if __name__ == "__main__":
    unittest.main()
```

### Отладка
- Используй `print()` для проверки значений.
- В IDE (например, PyCharm) ставь точки останова (breakpoints).

---

## 3. Оптимизация кода

- **Крестики-нолики**: Можно добавить проверку ввода через `try-except`.
- **To-Do список**: Используй генераторы для чтения больших списков задач.

Пример оптимизации ввода:
```python
def safe_input(prompt):
    while True:
        try:
            return int(input(prompt))
        except ValueError:
            print("Введи число!")
```

---

## 4. Документирование

Добавь документацию к проекту в виде комментариев и файла `README.md`.

### Пример для `TaskManager`
```python
class TaskManager:
    """Управляет списком задач с сохранением в файл."""
    def add_task(self, task):
        """Добавляет новую задачу в список.
        
        Args:
            task (str): Текст задачи.
        """
        self.tasks.append({"task": task, "done": False})
        self.save_tasks()
```

### README.md
```
# To-Do Список
Простое приложение для управления задачами.

## Функции
- Добавление задач
- Отметка задач как выполненных
- Сохранение в JSON

## Установка
1. Убедись, что Python установлен.
2. Запусти `main.py`.
```

---

## 5. Визуализация

### Структура проекта "Крестики-нолики"
```
[TicTacToe]
   ├── board (список)
   ├── current_player (строка)
   ├── print_board() (метод)
   ├── make_move() (метод)
   └── check_winner() (метод)
```

---

## 6. Задание

Выбери один проект или придумай свой:
1. Реализуй его, используя ООП, модули, работу с файлами и другие изученные темы.
2. Добавь тесты с `unittest`.
3. Напиши краткую документацию (5-10 строк).

Пример своего проекта: "Калькулятор бюджета" (учёт доходов и расходов).

---

## Советы
- Разбей проект на функции и классы.
- Тестируй по частям, чтобы легче находить ошибки.
- Документируй код — это пригодится в будущем.

---

Поздравляю! Ты завершил 8-недельный курс по Python! Теперь ты готов к реальным задачам. Выполни проект, и если что-то непонятно, пиши — я помогу!

# Неделя 9: Супер продвинутые темы

Добро пожаловать в финальный рывок! На этой неделе ты освоишь супер продвинутые концепции Python, которые используют опытные разработчики в сложных проектах. Мы разберём метаклассы, асинхронное программирование, управление памятью, функциональное программирование и оптимизацию производительности. Я объясню всё подробно, с примерами и визуализациями, чтобы ты мог применять эти техники в реальных задачах.

---

## 1. Метаклассы

Метаклассы — это "классы классов". Они определяют, как создаются сами классы.

### Основы
```python
class Meta(type):
    def __new__(cls, name, bases, attrs):
        print(f"Создаём класс {name}")
        attrs["created_by"] = "Meta"  # Добавляем атрибут
        return super().__new__(cls, name, bases, attrs)

class MyClass(metaclass=Meta):
    def say_hello(self):
        return "Привет!"

obj = MyClass()
print(obj.created_by)  # Вывод: Meta
print(obj.say_hello()) # Вывод: Привет!
```
Вывод:
```
Создаём класс MyClass
Meta
Привет!
```

### Подробности
- `type` — стандартный метакласс Python.
- `__new__` в метаклассе вызывается до создания класса.
- Используется для контроля создания классов (например, в ORM вроде SQLAlchemy).

### Пример: Singleton через метакласс
```python
class SingletonMeta(type):
    _instances = {}
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class Singleton(metaclass=SingletonMeta):
    def __init__(self):
        self.value = 42

s1 = Singleton()
s2 = Singleton()
s1.value = 100
print(s2.value)  # Вывод: 100 (один и тот же объект)
```

---

## 2. Асинхронное программирование

Асинхронность позволяет выполнять задачи параллельно, не блокируя основной поток. Используется для I/O-операций (например, запросы к API).

### Основы с `asyncio`
```python
import asyncio

async def say_after(delay, message):
    await asyncio.sleep(delay)
    print(message)

async def main():
    print("Начало")
    await asyncio.gather(
        say_after(1, "Привет"),
        say_after(2, "Мир")
    )
    print("Конец")

asyncio.run(main())
```
Вывод:
```
Начало
Привет (через 1 сек)
Мир (через 2 сек)
Конец
```

### Подробности
- `async def` — определяет асинхронную функцию.
- `await` — ждёт завершения задачи.
- `asyncio.gather` — запускает несколько задач параллельно.

### Пример: Асинхронные запросы
```python
import aiohttp
import asyncio

async def fetch_url(session, url):
    async with session.get(url) as response:
        return await response.text()

async def main():
    async with aiohttp.ClientSession() as session:
        tasks = [
            fetch_url(session, "https://api.github.com"),
            fetch_url(session, "https://api.example.com")
        ]
        results = await asyncio.gather(*tasks)
        for i, result in enumerate(results):
            print(f"Результат {i}: {result[:50]}...")

asyncio.run(main())
```

---

## 3. Управление памятью и сборка мусора

Python автоматически управляет памятью, но ты можешь влиять на этот процесс.

### Основы
```python
import gc
import sys

class MyObject:
    def __init__(self, name):
        self.name = name

obj = MyObject("test")
print(sys.getrefcount(obj))  # Вывод: 2 (obj + getrefcount)
del obj
gc.collect()  # Принудительная сборка мусора
print("Объект удалён")
```

### Подробности
- `sys.getrefcount()` — количество ссылок на объект.
- `gc` — модуль для управления сборкой мусора.
- Циклические ссылки (например, объект ссылается сам на себя) требуют `gc`.

### Пример: Циклическая ссылка
```python
import gc

class Node:
    def __init__(self):
        self.next = None

a = Node()
b = Node()
a.next = b
b.next = a  # Цикл
del a
del b
print(gc.collect())  # Вывод: число освобождённых объектов
```

---

## 4. Функциональное программирование

Python поддерживает элементы функционального программирования: чистые функции, неизменяемость, высшие функции.

### Пример: `map`, `filter`, `reduce`
```python
from functools import reduce

numbers = [1, 2, 3, 4]
squares = list(map(lambda x: x**2, numbers))  # Возведение в квадрат
evens = list(filter(lambda x: x % 2 == 0, numbers))  # Чётные числа
product = reduce(lambda x, y: x * y, numbers)  # Произведение

print(squares)  # Вывод: [1, 4, 9, 16]
print(evens)    # Вывод: [2, 4]
print(product)  # Вывод: 24
```

### Подробности
- `map` — применяет функцию к каждому элементу.
- `filter` — отбирает элементы по условию.
- `reduce` — сворачивает последовательность в одно значение.

### Чистая функция
```python
def add(a, b):
    return a + b  # Без побочных эффектов

print(add(3, 5))  # Вывод: 8
```

---

## 5. Оптимизация производительности

### Использование `timeit`
```python
import timeit

def slow_loop():
    result = []
    for i in range(10000):
        result.append(i)
    return result

def fast_loop():
    return [i for i in range(10000)]

print(timeit.timeit(slow_loop, number=100))  # Вывод: ~0.15 сек
print(timeit.timeit(fast_loop, number=100))  # Вывод: ~0.08 сек
```

### Подробности
- Списковые включения быстрее циклов с `append`.
- Используй `numpy` для числовых вычислений:
```python
import numpy as np

arr = np.arange(10000)
print(timeit.timeit(lambda: arr * 2, number=100))  # Ещё быстрее!
```

### Профилирование
```python
import cProfile

def complex_function():
    return sum(i * i for i in range(10000))

cProfile.run("complex_function()")
```
Вывод покажет, где тратится время.

---

## 6. Визуализация

### Работа метакласса
```
[Meta] → [__new__] → [MyClass] → [obj]
```

### Асинхронность
```
[main] → [say_after(1)] --- [say_after(2)] → [Конец]
         | 1 сек         | 2 сек         |
```

---

## 7. Упражнения

### Упражнение 1: Метакласс для логирования
Создай метакласс `LoggingMeta`, который добавляет метод `log()` ко всем классам, выводящий "Класс {name} создан".

Пример вызова:
```python
class MyClass(metaclass=LoggingMeta):
    pass

obj = MyClass()
obj.log()  # Вывод: Класс MyClass создан
```

### Упражнение 2: Асинхронный таймер
Напиши асинхронную функцию, которая запускает 5 задач с разной задержкой (1-5 сек) и выводит их результаты параллельно.

Пример вывода:
```
Задача 1 завершена (1 сек)
Задача 2 завершена (2 сек)
...
```

---

## Советы
- Используй метаклассы только для сложных задач (например, фреймворков).
- Тестируй асинхронность с реальными API.
- Профилируй код, чтобы находить узкие места.

---

Поздравляю! Ты освоил супер продвинутые темы Python. Теперь ты на уровне профессионалов! Выполни упражнения, и если что-то непонятно, пиши — я помогу!

# Неделя 10: Всё, что мы ещё не охватили

Добро пожаловать в бонусную неделю! Здесь я собрал темы, которые не вошли в предыдущие 9 недель, но которые сделают тебя ещё более уверенным пользователем Python. Мы разберём редкие встроенные модули, трюки с синтаксисом, работу с байтами, дескрипторы, аннотации типов и многое другое. Всё будет подробно, с примерами и визуализациями.

---

## 1. Редкие встроенные модули

Python имеет множество модулей, о которых редко говорят, но они невероятно полезны.

### `collections`
```python
from collections import Counter, defaultdict, namedtuple

# Counter: подсчёт элементов
words = ["cat", "dog", "cat", "bird"]
count = Counter(words)
print(count)  # Вывод: Counter({'cat': 2, 'dog': 1, 'bird': 1})

# defaultdict: словарь с значением по умолчанию
d = defaultdict(int)
d["key"] += 1
print(d)  # Вывод: defaultdict(<class 'int'>, {'key': 1})

# namedtuple: именованные кортежи
Point = namedtuple("Point", ["x", "y"])
p = Point(3, 4)
print(p.x, p.y)  # Вывод: 3 4
```

### `itertools`
```python
from itertools import permutations, combinations, cycle

# Перестановки
print(list(permutations("ABC", 2)))  # Вывод: [('A', 'B'), ('A', 'C'), ('B', 'A'), ...]

# Комбинации
print(list(combinations([1, 2, 3], 2)))  # Вывод: [(1, 2), (1, 3), (2, 3)]

# Бесконечный цикл
counter = 0
for item in cycle(["a", "b"]):
    print(item, end=" ")  # Вывод: a b a b ...
    counter += 1
    if counter > 5: break
```

---

## 2. Работа с байтами и кодировками

Иногда нужно работать с данными на уровне байтов.

### Основы
```python
text = "Привет"
byte_data = text.encode("utf-8")  # Строку в байты
print(byte_data)  # Вывод: b'\xd0\x9f\xd1\x80\xd0\xb8\xd0\xb2\xd0\xb5\xd1\x82'
decoded = byte_data.decode("utf-8")  # Байты в строку
print(decoded)  # Вывод: Привет
```

### `bytes` и `bytearray`
```python
b = bytes([65, 66, 67])  # Неизменяемый
print(b)  # Вывод: b'ABC'

ba = bytearray([65, 66, 67])  # Изменяемый
ba[0] = 68
print(ba)  # Вывод: bytearray(b'DBC')
```

---

## 3. Дескрипторы

Дескрипторы — это объекты, которые управляют доступом к атрибутам класса.

### Пример
```python
class Descriptor:
    def __init__(self, name):
        self.name = name
    
    def __get__(self, obj, objtype):
        return getattr(obj, f"_{self.name}")
    
    def __set__(self, obj, value):
        if not isinstance(value, int):
            raise ValueError("Только числа!")
        setattr(obj, f"_{self.name}", value)

class MyClass:
    age = Descriptor("age")
    
    def __init__(self, age):
        self.age = age

obj = MyClass(25)
print(obj.age)  # Вывод: 25
obj.age = 30
print(obj.age)  # Вывод: 30
# obj.age = "string"  # Ошибка: Только числа!
```

### Подробности
- `__get__`, `__set__`, `__delete__` — методы дескриптора.
- Используется в ORM, свойствах (`@property` — это дескриптор).

---

## 4. Аннотации типов

Аннотации типов улучшают читаемость и помогают инструментам вроде `mypy`.

### Пример
```python
def add(a: int, b: int) -> int:
    return a + b

name: str = "Алексей"
numbers: list[int] = [1, 2, 3]

from typing import Dict, Optional
def get_user(id: int) -> Optional[Dict[str, str]]:
    return {"name": "Оля"} if id == 1 else None

print(add(3, 5))  # Вывод: 8
```

### Подробности
- Не влияют на выполнение, только для документации и проверки.
- `typing` — модуль для сложных типов (`List`, `Union`, `Callable`).

---

## 5. Трюки с синтаксисом

Python полон скрытых возможностей.

### Распаковка
```python
a, *b, c = [1, 2, 3, 4, 5]
print(a, b, c)  # Вывод: 1 [2, 3, 4] 5

coords = {"x": 10, "y": 20}
print({"z": 30, **coords})  # Вывод: {'z': 30, 'x': 10, 'y': 20}
```

### Условные выражения в одну строку
```python
x = 10
result = "положительное" if x > 0 else "отрицательное или ноль"
print(result)  # Вывод: положительное
```

### `walrus operator` (:=) (Python 3.8+)
```python
while (line := input("Введи строку: ")) != "stop":
    print(f"Ты ввёл: {line}")
```

---

## 6. Работа с `sys` и `os`

Эти модули дают доступ к системным функциям.

### Пример
```python
import sys
import os

print(sys.platform)  # Вывод: win32 / linux / darwin
print(os.getcwd())   # Текущая директория
os.makedirs("test_dir", exist_ok=True)  # Создать папку
print(os.path.join("test_dir", "file.txt"))  # Путь: test_dir/file.txt
```

---

## 7. Визуализация

### Структура `Counter`
```
[words] → [Counter] → {'cat': 2, 'dog': 1, 'bird': 1}
```

### Дескриптор
```
[MyClass] → [age] → [Descriptor] → [__get__ / __set__] → [_age]
```

---

## 8. Упражнения

### Упражнение 1: Подсчёт символов
Используя `Counter`, напиши функцию, которая принимает строку и возвращает топ-3 самых частых символа.

Пример вызова:
```python
print(top_chars("hello world"))  # Вывод: [('l', 3), ('o', 2), ('h', 1)]
```

### Упражнение 2: Дескриптор с валидацией
Создай дескриптор `PositiveNumber`, который позволяет устанавливать только положительные числа.

Пример вызова:
```python
class Item:
    price = PositiveNumber("price")
    def __init__(self, price):
        self.price = price

item = Item(100)
print(item.price)  # Вывод: 100
# item.price = -5  # Ошибка: Только положительные числа!
```

---

## Советы
- Изучай документацию на редкие модули — там много сокровищ.
- Экспериментируй с байтами для работы с файлами или сетью.
- Используй аннотации типов в больших проектах.

---

Поздравляю! Ты прошёл 10 недель и теперь знаешь Python на уровне эксперта. Эти темы дополняют твои навыки и открывают новые возможности. Выполни упражнения, и если что-то нужно разобрать подробнее, пиши — я всегда рядом!

# Неделя 11: Алгоритмы, регулярные выражения и сложные структуры данных

Добро пожаловать в 11-ю неделю! Здесь ты освоишь ключевые алгоритмы (сортировка, поиск), регулярные выражения для работы с текстом и сложные структуры данных — как из модуля `collections`, так и кастомные (деревья, очереди). Всё будет подробно, с примерами и визуализациями, для базового и продвинутого уровня.

---

## 1. Алгоритмы сортировки

### Базовый уровень: Пузырьковая сортировка
Простая, но медленная (O(n²)).
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

numbers = [64, 34, 25, 12, 22]
print(bubble_sort(numbers))  # Вывод: [12, 22, 25, 34, 64]
```

### Продвинутый уровень: Быстрая сортировка (Quick Sort)
Эффективная сортировка (O(n log n) в среднем).
```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

numbers = [64, 34, 25, 12, 22]
print(quick_sort(numbers))  # Вывод: [12, 22, 25, 34, 64]
```

### Встроенная сортировка
```python
numbers = [64, 34, 25, 12, 22]
numbers.sort()  # Сортировка на месте
print(numbers)  # Вывод: [12, 22, 25, 34, 64]

sorted_numbers = sorted(numbers, reverse=True)  # Новая отсортированная копия
print(sorted_numbers)  # Вывод: [64, 34, 25, 22, 12]
```

---

## 2. Алгоритмы поиска

### Базовый уровень: Линейный поиск
O(n) — проверяет каждый элемент.
```python
def linear_search(arr, target):
    for i, value in enumerate(arr):
        if value == target:
            return i
    return -1

numbers = [64, 34, 25, 12, 22]
print(linear_search(numbers, 25))  # Вывод: 2
```

### Продвинутый уровень: Бинарный поиск
O(log n) — работает только с отсортированным массивом.
```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

numbers = sorted([64, 34, 25, 12, 22])
print(binary_search(numbers, 25))  # Вывод: 2
```

---

## 3. Регулярные выражения (`re`)

Регулярные выражения — мощный инструмент для поиска и обработки текста.

### Основы
```python
import re

text = "Мой email: test@example.com, дата: 2023-10-15"
emails = re.findall(r"[\w\.-]+@[\w\.-]+", text)  # Поиск email
print(emails)  # Вывод: ['test@example.com']

dates = re.findall(r"\d{4}-\d{2}-\d{2}", text)  # Поиск даты
print(dates)  # Вывод: ['2023-10-15']
```

### Полезные методы
| Метод         | Что делает                          | Пример                        |
|---------------|-------------------------------------|-------------------------------|
| `findall()`   | Все совпадения в список            | `re.findall(r"\d+", "12 34")` → `["12", "34"]` |
| `search()`    | Первое совпадение (объект Match)   | `re.search(r"\d", "abc1")`    |
| `match()`     | Совпадение с начала строки         | `re.match(r"abc", "abcdef")`  |
| `sub()`       | Замена совпадений                  | `re.sub(r"\d", "X", "a1b2")` → `"aXbX"` |

### Пример: Парсинг логов
```python
log = "ERROR 2023-10-15 12:34:56: Crash detected"
pattern = r"(ERROR|WARNING) (\d{4}-\d{2}-\d{2}) (\d{2}:\d{2}:\d{2}): (.+)"
match = re.search(pattern, log)
if match:
    level, date, time, message = match.groups()
    print(f"Уровень: {level}, Сообщение: {message}")  # Вывод: Уровень: ERROR, Сообщение: Crash detected
```

---

## 4. Сложные структуры данных из `collections`

### `deque` (двусторонняя очередь)
```python
from collections import deque

d = deque([1, 2, 3])
d.appendleft(0)  # Добавление слева
d.append(4)      # Добавление справа
print(d)         # Вывод: deque([0, 1, 2, 3, 4])
d.popleft()      # Удаление слева
print(d)         # Вывод: deque([1, 2, 3, 4])
```

### `OrderedDict`
Сохраняет порядок добавления элементов (до Python 3.7 обычные словари этого не делали).
```python
from collections import OrderedDict

od = OrderedDict()
od["b"] = 2
od["a"] = 1
print(od)  # Вывод: OrderedDict([('b', 2), ('a', 1)])
```

### `ChainMap`
Объединяет несколько словарей.
```python
from collections import ChainMap

dict1 = {"a": 1}
dict2 = {"b": 2}
combined = ChainMap(dict1, dict2)
print(combined["a"], combined["b"])  # Вывод: 1 2
```

---

## 5. Кастомные структуры данных

### Двоичное дерево
```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

class BinaryTree:
    def __init__(self):
        self.root = None
    
    def insert(self, value):
        if not self.root:
            self.root = TreeNode(value)
        else:
            self._insert_recursive(self.root, value)
    
    def _insert_recursive(self, node, value):
        if value < node.value:
            if node.left is None:
                node.left = TreeNode(value)
            else:
                self._insert_recursive(node.left, value)
        else:
            if node.right is None:
                node.right = TreeNode(value)
            else:
                self._insert_recursive(node.right, value)

tree = BinaryTree()
for val in [5, 3, 7, 1, 4]:
    tree.insert(val)
```

### Очередь (Queue)
```python
class Queue:
    def __init__(self):
        self.items = []
    
    def enqueue(self, item):
        self.items.append(item)
    
    def dequeue(self):
        return self.items.pop(0) if self.items else None
    
    def is_empty(self):
        return len(self.items) == 0

q = Queue()
q.enqueue(1)
q.enqueue(2)
print(q.dequeue())  # Вывод: 1
```

---

## 6. Визуализация

### Бинарное дерево
```
     5
    / \
   3   7
  / \
 1   4
```

### Регулярное выражение (email)
```
[\w\.-]+ @ [\w\.-]+
[буквы.-]+ @ [буквы.-]+
```

---

## 7. Упражнения

### Упражнение 1: Сортировка и поиск
Напиши функцию, которая сортирует список методом слияния (merge sort) и ищет элемент бинарным поиском.

Пример вызова:
```python
numbers = [64, 34, 25, 12, 22]
sorted_nums = merge_sort(numbers)
print(sorted_nums)  # Вывод: [12, 22, 25, 34, 64]
print(binary_search(sorted_nums, 25))  # Вывод: 2
```

### Упражнение 2: Парсинг текста
Используя регулярные выражения, извлеки все телефонные номера формата `+X-XXX-XXX-XX-XX` из текста.

Пример вызова:
```python
text = "Мой номер: +7-123-456-78-90, другой: +1-987-654-32-10"
print(find_phones(text))  # Вывод: ['+7-123-456-78-90', '+1-987-654-32-10']
```

---

## Советы
- Тренируйся с алгоритмами на задачах (например, LeetCode).
- Используй регулярки для парсинга логов или данных.
- Экспериментируй с деревьями и очередями для сложных задач.

---

Поздравляю! Ты прошёл 11 недель и теперь знаешь Python на уровне, о котором многие только мечтают. Выполни упражнения, и если что-то нужно углубить, пиши — я готов расширять курс дальше!
